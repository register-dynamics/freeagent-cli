#!/usr/bin/env ruby

require 'dotenv/load'
require 'thor'
require_relative '../lib/freeagent'

def match type, collection, needle, *values
  found = collection.select do |item|
    values.map(&:to_proc).any? {|v| v.call(item) == needle }
  end
  if found.none?
    possibles = collection.product(values).map {|item, value| value.to_proc.call(item).to_s }
    raise ArgumentError, "No #{type} matching '#{needle}' found, expecting one from #{possibles}"
  end
  unless found.one?
    raise ArgumentError, "Ambiguous #{type}: could be #{found.map(&:url).join(', ')}"
  end
  found.first
end

module Freeagent
  class Timeslips < Thor
    no_commands do
      def api
        @api ||= API.new
      end
    end

    desc 'list [-U USER] [-P PROJECT [-T TASK]] [-f FROM] [-t TO]', "List timeslips"
    method_option :user, aliases: '-U', type: :string, default: nil, desc: 'Name or email of a user'
    method_option :project, aliases: '-P', type: :string, default: nil, desc: 'Name of a project'
    method_option :task, aliases: '-T', type: :string, default: nil, desc: 'Name of a task within the project'
    method_option :from, aliases: '-f', type: :string, default: nil, desc: 'Date to list timeslips from'
    method_option :to, aliases: '-t', type: :string, default: nil, desc: 'Date to list timeslips to'
    def list
      raise ArgumentError, '--project must be specified if --task if used' if options[:project].nil? && !options[:task].nil?

      from = options[:from].nil? ? nil : Date::parse(options[:from])
      to = options[:to].nil? ? nil : Date::parse(options[:to])
      user = options[:user].nil? ? nil : match(:user, api.users, options[:user], :first_name, :last_name, :email)
      project = options[:project].nil? ? nil : match(:project, api.projects, options[:project], :name)
      task = options[:task].nil? ? nil : match(:task, api.tasks(project), options[:task], :name)

      users = Hash.new {|cache, url| cache[url] = api.user url.split('/').last }
      users[user.url] = user unless user.nil?
      projects = Hash.new {|cache, url| cache[url] = api.project url.split('/').last }
      projects[project.url] = project unless project.nil?
      tasks = Hash.new {|cache, url| cache[url] = api.task url.split('/').last }
      tasks[task.url] = task unless task.nil?

      api.timeslips(user: user, project: project, task: task, from: from, to: to).each do |timeslip|
        puts [
          Date::parse(timeslip.dated_on).strftime('%a %d %b %Y'),
          users[timeslip.user].email,
          projects[timeslip.project].name,
          tasks[timeslip.task].name,
          timeslip.hours,
          timeslip.comment
        ].join("\t")
      end
    end

    desc 'create USER PROJECT TASK [FROM [TO]]', "Create timeslips"
    method_option :hours, aliases: '-h', type: :numeric, default: 8, desc: "Number of hours per day"
    method_option :weekends, aliases: '-w', type: :boolean, default: false, desc: "Create timeslips on Saturdays and Sundays"
    method_option :comment, aliases: '-c', type: :string, default: nil, desc: "Comment to add to any created timeslips"
    def create user, project, task, from = nil, to = nil
      from = from.nil? ? Date::today : Date::parse(from)
      to = to.nil? ? from : Date::parse(to)
      user = match :user, api.users, user, :first_name, :last_name, :email
      project = match :project, api.projects, project, :name
      task = match :task, api.tasks(project), task, :name

      puts "Creating timeslips for #{user.first_name} #{user.last_name} for task '#{task.name}' in project '#{project.name}' between #{from} and #{to} inclusive"
      timeslips = from.step(to).map do |date|
        next if (date.saturday? || date.sunday?) && !options[:weekends]
        {'task' => task.url, 'project' => project.url, 'user' => user.url, 'dated_on' => date.to_s, 'hours' => options[:hours], 'comment' => options[:comment]}
      end.reject(&:nil?)
      api.batch_create_timeslips timeslips
    end

    desc 'fill USER PROJECT TASK [FROM [TO]]', 'Fill remaining hours with new timeslips'
    method_option :hours, aliases: '-h', type: :numeric, default: 8, desc: "Number of hours per day"
    method_option :weekends, aliases: '-w', type: :boolean, default: false, desc: "Create timeslips on Saturdays and Sundays"
    method_option :comment, aliases: '-c', type: :string, default: nil, desc: "Comment to add to any created timeslips"
    def fill user, project, task, from = nil, to = nil
      from = from.nil? ? Date::today : Date::parse(from)
      to = to.nil? ? from : Date::parse(to)
      user = match :user, api.users, user, :first_name, :last_name, :email
      project = match :project, api.projects, project, :name
      task = match :task, api.tasks(project), task, :name

      existing = api.timeslips(user: user, from: from, to: to).reduce(Hash.new) do |hash, timeslip|
        date = Date::parse timeslip.dated_on
        hash.update({date => (hash[date] || 0) + timeslip.hours.to_f})
      end

      puts "Filling timeslips for #{user.first_name} #{user.last_name} up to #{options[:hours]}hrs using task '#{task.name}' in project '#{project.name}' between #{from} and #{to} inclusive"
      timeslips = from.step(to).map do |date|
        next if (date.saturday? || date.sunday?) && !options[:weekends]
        existing_hours = existing[date] || 0
        adding_hours = options[:hours] - existing_hours
        next if adding_hours <= 0

        {'task' => task.url, 'project' => project.url, 'user' => user.url, 'dated_on' => date.to_s, 'hours' => adding_hours.to_s, 'comment' => options[:comment]}
      end.reject(&:nil?)
      api.batch_create_timeslips timeslips
    end

    desc 'delete USER PROJECT TASK [FROM [TO]]', 'Delete timeslips'
    def delete user, project, task, from = nil, to = nil
      from = from.nil? ? Date::today : Date::parse(from)
      to = to.nil? ? from : Date::parse(to)
      user = match :user, api.users, user, :first_name, :last_name, :email
      project = match :project, api.projects, project, :name
      task = match :task, api.tasks(project), task, :name

      puts "Deleting timeslips for #{user.first_name} #{user.last_name} for task '#{task.name}' in project '#{project.name}' between #{from} and #{to} inclusive"
      api.timeslips(user: user, project: project, task: task, from: from, to: to).each do |timeslip|
        api.delete_timeslip(timeslip)
      end
    end
  end

  class Command < Thor
    desc "timeslips", "Create, read, update and delete timeslips"
    subcommand "timeslips", Timeslips
  end
end

Freeagent::Command.start
